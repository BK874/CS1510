
\documentclass[letterpaper,notitlepage,twoside]{article}

% Basic imports, increase margins...
\usepackage[margin=0.75in]{geometry}
% Finite State Machine stuff
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
% Format tables nicely
\usepackage[latin1]{inputenc}
\usepackage{array}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath,amsthm}

\usepackage{algorithm}          %  float wrapper for algorithms.
\usepackage{algpseudocode}      % layout for algorithmicx

\renewcommand{\implies}{\Rightarrow} % redefine command "implies"
\renewcommand{\iff}{\Leftrightarrow} % double arrow
\newcommand{\maps}{\rightarrow} % define command "map"
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\N}{\mathbb{N}} % natural number
\newcommand{\Q}{\mathbb{Q}} % rational number
\newcommand{\R}{\mathbb{R}} % real number
\newcommand{\Z}{\mathbb{Z}} % integers
\newcommand\tab[1][1cm]{\hspace*{#1}} %\tab command

% Add more packages that you use here...

\begin{document}
\title{Homework 30}
\author{Brian Knotten, Brett Schreiber, Brian Falkenstein}
\maketitle

\section*{12}
In the CREW algorithm, the concurrent read step is $D[i,j] \gets min(D[i, j], D[i, m] + D[m, j])$, since processor $i = 5$ is reading $D[i = 5, m = 4]$ at the same time processor $j = 4$ is reading $D[m = 5, j = 4]$ (These represent the same memory location). To make the algorithm EREW, make $n$ copies of $D$ into a 3D array $D'$ so that each of the $n^3$ processors $p_{i, j, k}$ is reading from a different cell in $D'$.
\\\\
$n^3$ processors can make $n$ copies of $D$ (which is size $n^2$) into a 3D array $D'$ in $\log^2 n$ time.
\\\\
With $n^3$ processors, the concurrent read step of the CREW algorithm becomes an exclusive read step: $D[i, j, k] \gets min(D[i, j, k], D[i, m, k] + D[m, j, k])$. But now each $D[i, j, k]$ must be synchronized over all $k$, since any one of the $k$s could have changed the minimum. So an extra step must be added to synchronize $D[i, j, k]$ for all $k$.

\section{*13}
The algorithm can be modified as follows to return the actual paths. First, when setting up the 2D array $D$ that contains information for all pairs $(v_i, v_j) \in G$, instead of storing the distance between $v_i$ and $v_j$ store a pair: the first element is a list of vertices representing a path from $v_i$ to $v_j$, and the second element is the distance between $v_i$ and $v_j$.
\\\\
When setting up $D$ initially, $D[i, j]$ is initialized as follows: if $i = j$, then $D[i, j] \gets ([v_i], 0)$. Else if there is an edge between $v_i$ and $v_j$, then $D[i, j] \gets ([v_i, v_j], edge_weight(v_i, v_j))$. Otherwise, $D[i, j] \gets ([], \infty)$.
\\\\
When $D[i, j]$ is updated to be $D[i, m] + D[m, j]$, then $D[i, j] \gets (fst(D[i, m]) ++ fst(D[m, j]), snd(D[i, m]) + snd(D[m, j]))$, where $fst$ returns the first element of a tuple, $snd$ returns the second element of a tuple, and $a ++ b$ represents list $a$ concatenated with list $b$.
\end{document}
