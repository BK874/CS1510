
\documentclass[letterpaper,notitlepage,twoside]{article}

% Basic imports, increase margins...
\usepackage[margin=0.75in]{geometry}
% Finite State Machine stuff
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
% Format tables nicely
\usepackage[latin1]{inputenc}
\usepackage{array}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath,amsthm}

\usepackage{algorithm}          %  float wrapper for algorithms.
\usepackage{algpseudocode}      % layout for algorithmicx

\renewcommand{\implies}{\Rightarrow} % redefine command "implies"
\renewcommand{\iff}{\Leftrightarrow} % double arrow
\newcommand{\maps}{\rightarrow} % define command "map"
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\N}{\mathbb{N}} % natural number
\newcommand{\Q}{\mathbb{Q}} % rational number
\newcommand{\R}{\mathbb{R}} % real number
\newcommand{\Z}{\mathbb{Z}} % integers
\newcommand\tab[1][1cm]{\hspace*{#1}} %\tab command

% Add more packages that you use here...

\begin{document}
\title{Homework 30}
\author{Brian Knotten, Brett Schreiber, Brian Falkenstein}
\maketitle

\section*{12}
In the CREW algorithm, the concurrent read step is $D[i,j] \gets min(D[i, j], D[i, m] + D[m, j])$, since processor $i = 5$ is reading $D[i = 5, m = 4]$ at the same time processor $j = 4$ is reading $D[m = 5, j = 4]$ (These represent the same memory location). To make the algorithm EREW, make $n$ copies of $D$ into a 3D array $D'$ so that each of the $n^3$ processors $p_{i, j, k}$ is reading from a different cell in $D'$.
\\\\
$n^3$ processors can make $n$ copies of $D$ (which is size $n^2$) into a 3D array $D'$ in $\log^2 n$ time.
\\\\
With $n^3$ processors, the concurrent read step of the CREW algorithm becomes an exclusive read step: $D[i, j, k] \gets min(D[i, j, k], D[i, m, k] + D[m, j, k])$. But now each $D[i, j, k]$ must be synchronized over all $k$, since any one of the $k$s could have changed the minimum. 
\begin{verbatim}
while c <= 1:
	if k<c:
		D'[i, j, k+c] = D'[i, j, k]
	end
	b = floor(c/2)
	while x < b do:
		D'[i, j, i] = min(D'[i, j, i], D'[i+b, k+b, i] + D'[k+b, j, i])
	end
	if i == 0 & j == 0 & k == 0
		return D'[0, 0, 0]
	end
end
\end{verbatim}

\begin{algorithm}
    \begin{algorithmic}%[1]
       \caption{EREW $O(log(n))$ algorithm}
        \Require A string $C$ of size $n$ to be expanded to an $n^2\times n$ array of copies, a processor $p_{i, j}$, a memory location $M$ of size $n^2$
        \State $M[i][j] \gets i$ \Comment{Use $n^2$ processors to write $1...k$ into $M[i]$ for all $i$.}
        \State $number\_of\_copies \gets 1$ \Comment{This is a variable to store the current number of copies made.}
        \While{$number\_of\_copies < n^2$}
            \If{$j < number\_of\_copies$} \Comment{Only use the processors needed to make $c$ copies.}
                \State $C[i][j+number\_of\_copies] \gets C[i][j]$ \Comment Copy current character to new copy location
            \EndIf
            \If{$number\_of\_copies > n$}
                \State $number\_of\_copies \gets number\_of\_copies + n$ \Comment{All $n^2$ processors can copy at most $n$ strings eath of length $n$.}
            \Else
                \State $number\_of\_copies \gets number\_of\_copies * 2$ \Comment{Otherwise, with less than $n^2$ processors, the number of copies can be doubled.}
            \EndIf
        \EndWhile
        \If{$C[j][2i+j] \neq C[n - i + j][2i + j]$} \Comment{Each processor compares two individual characters to see if the prefix is of size $k$. The extra dimension on $C$ is to ensure that all processors are reading from different places in memory.}
            \State $M[i][j] \gets 0$ \Comment{If any of the pairs of characters don't match, then that $k$ isn't viable.}
        \EndIf
        
        \State $z \gets \lfloor{n/2}\rfloor$ \Comment{Flatten the $M$ array so that any zero entry makes $M[i][1] \gets 0$.}
        \While{$j < z$}
            \State $M[i][j] \gets MIN(M[i][j], M[i][j + z])$ \Comment{If any entry in the $j$ column is zero, then $M[i][1]$ is 0.}
            \State $z \gets \lfloor{z/2}\rfloor$
        \EndWhile
        
        \State $y \gets \lfloor{n/2}\rfloor$ \Comment{Now get the max of the $M[1]$ array}
        \While {$i < y$}
            \State $M[i][1] \gets MAX(M[i][1], M[i+y][1]$) \Comment{A processor can take the max of 2 values in constant time. Overwrite the greater number into $M[i]$. After $\log n$ iterations, $M[1][1]$ will contain the maximum $k$.}
            \State $y \gets \lfloor{y/2}\rfloor$
        \EndWhile
        \If{$i==1$ and $j==1$} \Comment{Designate the first processor to exclusively read and output the solution.}
            \State Output $M[1][1]$
        \EndIf
    \end{algorithmic}
\end{algorithm}


\section*{13}
The algorithm can be modified as follows to return the actual paths. First, when setting up the 2D array $D$ that contains information for all pairs $(v_i, v_j) \in G$, instead of storing the distance between $v_i$ and $v_j$ store a pair: the first element is a list of vertices representing a path from $v_i$ to $v_j$, and the second element is the distance between $v_i$ and $v_j$.
\\\\
When setting up $D$ initially, $D[i, j]$ is initialized as follows: if $i = j$, then $D[i, j] \gets ([v_i], 0)$. Else if there is an edge between $v_i$ and $v_j$, then $D[i, j] \gets ([v_i, v_j], edge_weight(v_i, v_j))$. Otherwise, $D[i, j] \gets ([], \infty)$.
\\\\
When $D[i, j]$ is updated to be $D[i, m] + D[m, j]$, then $D[i, j] \gets (fst(D[i, m]) ++ fst(D[m, j]), snd(D[i, m]) + snd(D[m, j]))$, where $fst$ returns the first element of a tuple, $snd$ returns the second element of a tuple, and $a ++ b$ represents list $a$ concatenated with list $b$.
\end{document}
