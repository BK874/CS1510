
\documentclass[letterpaper,notitlepage,twoside]{article}

% Basic imports, increase margins...
\usepackage[margin=0.75in]{geometry}
% Finite State Machine stuff
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows, automata}
% Format tables nicely
\usepackage[latin1]{inputenc}
\usepackage{array}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath,amsthm}

\usepackage{algorithm}          %  float wrapper for algorithms.
\usepackage{algpseudocode}      % layout for algorithmicx
\usepackage{float} % http:/ctan.org/pkg/flot - [H] float parameter forces a 'float' (algorithm block) to remain in a location

\renewcommand{\implies}{\Rightarrow} % redefine command "implies"
\renewcommand{\iff}{\Leftrightarrow} % double arrow
\newcommand{\maps}{\rightarrow} % define command "map"
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\N}{\mathbb{N}} % natural number
\newcommand{\Q}{\mathbb{Q}} % rational number
\newcommand{\R}{\mathbb{R}} % real number
\newcommand{\Z}{\mathbb{Z}} % integers
\newcommand\tab[1][1cm]{\hspace*{#1}} %\tab command

% Add more packages that you use here...

\begin{document}
\title{Homework 31}
\author{Brian Knotten, Brett Schreiber, Brian Falkenstein}
\maketitle

\section*{2}
To give evidence that finding a fast efficient parallel algorithm (i.e. a $O(log^k(n))$ algorithm for some $k$ with a poly number of processors) for $N$ is at least as hard as finding a fast efficient parallel algorithm for the $BFV$ problem, you could present a parallel algorithm for the $BFV$ problem that is $O(log^k(n))$ for some $k$ with a poly number of processors that is only missing code for $N$. \\
The algorithm should convert the input from the $BFV$ problem to the input to the $N$ problem in at most poly-log time, run the missing code for $N$ using the converted input, and convert the output of the $N$ problem to the output of the $BFV$ in at most poly-log time. \\
Further, the missing code for $N$ should give a correct output given the input iff there is a correct output for the BFV problem given the input. \\
Given this parallel algorithm for the $BFV$missing the code for $N$, if you were to find parallel code for $N$ that runs in poly-log time with a poly number of processors then you would immediately have a poly-log algorithm for the $BFV$ problem with a poly number of processors by "plugging in" the code for $N$ into the parallel code for $BFV$. \\
Because the code we are plugging in is poly-log with a poly number of processors, our input/output transformations are also poly-log with a poly number of processors, and the code gives a correct output for $BFV$ iff the code for $N$ gives a correct output, the newly-constructed algorithm correctly solves the $BFV$ problem in poly-log time using a poly number of processors. \\
Therefore finding a fast efficient parallel algorithm for problem $N$ is at least as hard of a problem as finding a fast efficient parallel algorithm for the Boolean Formula Value problem. \\

\section*{16}



\section*{17}

\end{document}